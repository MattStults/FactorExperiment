// Generated by CoffeeScript 1.3.3
(function() {
  var HexBuilder;

  $.widget("stults.hexboard", {
    options: {
      size: 5,
      lhs: 0,
      rhs: 0,
      x: 150,
      y: 150,
      width: 300,
      height: 300,
      hwRatio: 1.15,
      boardId: "board",
      svg: null
    },
    _setOption: function(key, value) {
      if (key === 'size') {
        value = this._constrainSize(value);
      }
      if (key === 'lhs' || key === 'rhs') {
        value = this._constrainFactor(value);
      }
      if (key === 'hwRatio') {
        value = this._constrainRatio(value);
      }
      return this._super(key, value);
    },
    _setOptions: function(options) {
      this._super(options);
      return this.refresh();
    },
    _constrainSize: function(size) {
      if (size < 1) {
        return 1;
      }
      return size;
    },
    _constrainFactor: function(factor) {
      var max;
      if (factor < 0) {
        return 0;
      }
      max = (1 << this.options.size) - 1;
      if (factor > max) {
        return max;
      }
      return factor;
    },
    _constrainRatio: function(ratio) {
      this.isBuilt = false;
      if (ratio < 0.1) {
        return 0.1;
      }
      if (ratio > 10) {
        return 10;
      }
      return ratio;
    },
    _getBoardBySide: function(value, id) {
      var deselect, i, select, tag, _i, _ref;
      select = [];
      deselect = [];
      for (i = _i = 0, _ref = this.options.size; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        tag = id + i;
        if (((1 << i) & value) === 0) {
          deselect.push(tag);
        } else {
          select.push(tag);
        }
      }
      return [select, deselect];
    },
    _updateBoard: function(lhs, rhs) {
      var xDeselect, xSelect, yDeselect, ySelect, _ref, _ref1;
      _ref = this._getBoardBySide(lhs, ".x"), xSelect = _ref[0], xDeselect = _ref[1];
      _ref1 = this._getBoardBySide(rhs, ".y"), ySelect = _ref1[0], yDeselect = _ref1[1];
      $("." + this.options.boardId).filter($(xSelect.join(","))).filter($(ySelect.join(","))).addClass("select");
      return $((xDeselect.concat(yDeselect)).join(",")).removeClass("select");
    },
    refresh: function() {
      var value;
      if (!(this.options.svg != null)) {
        this.options.svg = this.element.svg('get');
      }
      if (!(this.isBuilt != null) || !this.isBuilt) {
        this.options.svg.clear();
        this.hexBuilder = new HexBuilder(50, this.options.hwRatio, [150, 100]);
        this.hexBuilder.buildGrid(this.options.boardId, this.options.svg, [0, 0], [this.options.size, this.options.size]);
        this.isBuilt = true;
      }
      value = this.options.lhs * this.options.rhs;
      if (value !== this.lastValue) {
        this.lastValue = value;
        this._updateBoard(this.options.lhs, this.options.rhs);
        return this._trigger("update", null, {
          value: value
        });
      }
    },
    _create: function() {
      this.element.addClass("hexboard");
      this.element.svg();
      return this.refresh();
    }
  });

  HexBuilder = (function() {

    function HexBuilder(height, hwRatio, origin) {
      this.height = height;
      this.hwRatio = hwRatio;
      this.origin = origin;
      this.width = height / hwRatio;
      this.sideLength = HexBuilder._buildSideLength(this.height / 2, this.width / 2);
      this.hexLine = HexBuilder._buildHexLine(this.height, this.width, this.sideLength);
      this.yOffset = height - (height - this.sideLength) / 2;
    }

    HexBuilder._gridPlot = function(pos, origin, width, yOffset) {
      return [origin[0] + (pos[0] - pos[1]) * 0.5 * width, origin[1] + (pos[0] + pos[1]) * yOffset];
    };

    HexBuilder.prototype.buildGrid = function(id, svg, start, dimensions) {
      var grid, gridGroup, posX, posY, x, y, _i, _j, _ref, _ref1, _ref2, _ref3, _ref4;
      gridGroup = svg.group();
      grid = [];
      for (x = _i = _ref = start[0], _ref1 = dimensions[0] + start[0]; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; x = _ref <= _ref1 ? ++_i : --_i) {
        grid[x] = [];
        for (y = _j = _ref2 = start[1], _ref3 = dimensions[1] + start[1]; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; y = _ref2 <= _ref3 ? ++_j : --_j) {
          posX = 0;
          posY = 0;
          _ref4 = HexBuilder._gridPlot([x, y], this.origin, this.width, this.yOffset), posX = _ref4[0], posY = _ref4[1];
          grid[x][y] = svg.polygon(gridGroup, this.hexLine, {
            transform: "translate(" + posX + "," + posY + ")"
          });
          $(grid[x][y]).addClass(id).addClass("x" + x).addClass("y" + y).addClass("row" + (x + y));
        }
      }
      return gridGroup;
    };

    HexBuilder._buildSideLength = function(halfHeight, halfWidth) {
      var a, b, c, root1, root2, sideLength, _ref;
      a = 0.75;
      b = halfHeight;
      c = -(Math.pow(halfHeight, 2) + Math.pow(halfWidth, 2));
      root1 = 0;
      root2 = 0;
      _ref = HexBuilder._solveQuadratic(a, b, c), root1 = _ref[0], root2 = _ref[1];
      sideLength = 0;
      if (!root1.isNaN && root1 > 0) {
        sideLength = root1;
      } else if (!root2.isNaN && root2 > 0) {
        sideLength = root2;
      } else {
        sideLength = (Math.sin(Math.PI / 6) * halfWidth).toFixed(2) * 2;
      }
      return sideLength;
    };

    HexBuilder._buildHexLine = function(height, width, sideLength) {
      var halfHeight, halfWidth, sidePosY;
      halfHeight = height / 2;
      halfWidth = width / 2;
      sidePosY = sideLength / 2;
      return [[0, halfHeight], [halfWidth, sidePosY], [halfWidth, -sidePosY], [0, -halfHeight], [-halfWidth, -sidePosY], [-halfWidth, sidePosY]];
    };

    HexBuilder._solveQuadratic = function(a, b, c) {
      var base, root1, root2;
      base = Math.pow(Math.pow(b, 2) - 4 * a * c, 0.5) / 2 / a;
      root1 = -b / 2 / a + base;
      root2 = -b / 2 / a - base;
      return [root1, root2];
    };

    return HexBuilder;

  })();

}).call(this);
